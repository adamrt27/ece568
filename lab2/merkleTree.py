#!/usr/bin/python3

# ECE568
# Lab 2: merkleTree.py

# The source materials you are provided in this lab are for your personal
# use only, as part of ECE568. Please do not post this file publicly
# (including on sites like GitHub, CourseHero, etc.).

# Please send any bug reports to Courtney Gibson <courtney.gibson@utoronto.ca>


import	collections.abc
from	cryptography.exceptions				import InvalidSignature
from	cryptography.hazmat.backends			import default_backend
from	cryptography.hazmat.primitives			import hashes
from	cryptography.hazmat.primitives			import serialization
from	cryptography.hazmat.primitives.asymmetric	import padding
from	hashlib						import sha256
import	hmac
import	json
import	os.path
from	sys						import argv


valuesFile	= 'values.json'
privateKeyFile	= 'privateKey.pem'
publicKeyFile	= 'publicKey.pem'

values		= []
hmacKey		= b'ECE568'


def sign(message):

	# Signs the message with the privateKey using SHA256 and
	# secure padding. Note that, for this lab, the signature
	# should be created on the ASCII encoding of the root hash.
	#
	# For example:
	# 'a9424f4004232abe6a074543035172da3460f1f4d2c47a110c0e5f9a74a610b6'
	#
	# NOT:
	# '\xa9\x42\x4f...'

	global	privateKey

	if isinstance(message, str):
		# If "message" is a string then encode it as a byte array
		message = message.encode('UTF-8')
	
	signature = privateKey.sign(message,
			padding.PSS(mgf = padding.MGF1(hashes.SHA256()),
				salt_length = padding.PSS.MAX_LENGTH),
			hashes.SHA256() )

	return signature


def verifySignature(message, signature):

	# Verifies the message signature that was created with the private key

	# *** TODO: You will need to add some code to verify the
	# *** signature created in sign(), above

	return False	# Returns False, for now, until you add your code


def hash(left, right=None):

	# Concatenate "left" and "right" and return the resulting
	# SHA256-based HMAC hash

	global	hmacKey

	# *** TODO: You will need to add some code to generate an HMAC
	# *** value from the provided strings. You do not need to implement
	# *** the HMAC function from scratch; you may call something like
	# *** hmac.new(...)

	# As a hint: a properly-calculated HMAC for the string 'a' should
	# be 819539069f383c771e4fe42437e82539fcd7fde44217ea7a4c4fcb9eaf4b07b9.
	# If you have a "left" and a "right", you should be hashing the
	# combined string. (For example, if left='hello' and right='world',
	# you should hash 'helloworld'.)

	HMAC = b'\x00' * 32	 # Placeholder, until you add your code

	return HMAC


def checkProofFormat(proof):

	# Checks that your "proof" structure appears to be in the
	# correct format. This is provided to help make sure you
	# program output adheres to the format specified in the
	# lab assignment; it's not a guarantee, but it should help

	# Check that it's a sequence: ['39abd...', '42abc...']
	assert isinstance(proof, collections.abc.Sequence)

	# Check that there are at least two elements
	assert len(proof) >= 2

	# Check that the first (N-1) elements are all 64-byte
	# hex strings (or None)

	for i in range(0,len(proof)-1):

		# An entry of None is acceptable
		if ( proof[i] is None ):
			continue

		# The element should be a string (not a byte array)
		assert isinstance(proof[i], str)

		# SHA256 hashes should be 64 bytes
		assert len(proof[i]) == 64

		# Check that it's a valid hex string
		try:
			hexValue = bytes.fromhex(proof[i])
			validHexString = True
		except:
			validHexString = False
		assert validHexString == True

	# Check that the last element (the signature) is a
	# 1024-byte hex string

	# The signature should be a string (not a byte array)
	assert isinstance(proof[-1], str)

	# The signature should be 1024 bytes
	assert len(proof[-1]) == 1024

	# Check that it's a valid hex string
	try:
		hexValue = bytes.fromhex(proof[-1])
		validHexString = True
	except:
		validHexString = False
	assert validHexString == True


def generateProof(hashedValue):

	# Generates a "proof" for the provided hash value, in the
	# format specified in the lab assignment:

	# [ HMAC1, HMAC2, HMAC3, ..., rootHMAC, signature ]


	# *** TODO: You will need to add code here, to generate a
	# *** "proof" for the specified hashedValue. See the lab
	# *** assignment doc for full details

	proof = [ '0'*64, '0'*1024 ]	# Placeholder, until you add your code

	# Check that you've generated your proof in what looks like
	# the correct format...

	checkProofFormat(proof)

	return proof


def loadValues(filename):

	# Loads the values from the values.json file. New test values
	# can be generated by running ./createValues.py

	global	values

	# Check that the JSON file exists
	if not os.path.isfile(filename):
		print("ERROR: Could not find %s" % filename)
		quit()

	# Load the entries from the JSON file
	with open(filename, 'r') as inputFile:
		values = json.load(inputFile)


def loadPrivateKey(filename):

	# Loads the private key from privateKey.pem. A new keypair can
	# be generated by running ./generateKeypair.py

	# Check that the file exists
	if not os.path.isfile(filename):
		print("ERROR: Could not find %s" % filename)
		quit()

	with open(filename, 'rb') as file:
		privateKey = serialization.load_pem_private_key(
			file.read(),
			password = None,
			backend = default_backend())

	return privateKey


def loadPublicKey(filename):

	# Loads the public key from privateKey.pem. A new keypair can
	# be generated by running ./generateKeypair.py

	# *** TODO: You will need to add code here, to load the public key.
	# *** See loadPrivateKey() for the general format of what you need
	# *** to do.

	publicKey = None	# Placeholder, until you add your code

	return publicKey


# Load the values 
loadValues(valuesFile)

# Load the private key
privateKey = loadPrivateKey(privateKeyFile)

# Load the public key
publicKey = loadPublicKey(publicKeyFile)

# Parse the command-line arguments

if ( len(argv) < 2 ):
	quit()

elif ( len(argv) == 2 ):

	# Generate a proof for the specified HMAC

	try:
		hashedValue = bytes.fromhex(argv[1])
	except:
		quit()

	proof = generateProof(hashedValue)

	print(proof)

else:

	# Verify the proof provided in the command arguments

	# Load the user's proof from the command-line arguments

	suppliedProof = []

	for i in range(1,len(argv)):

		if ( argv[i].lower() == 'none' ):
			suppliedProof += [ None ]
		else:
			suppliedProof += [ argv[i] ]

	# Check that it's a validly-formatted proof

	if ( checkProofFormat(suppliedProof) == False ):
		quit()

	# Calculate our own proof, based on the first hash

	# *** TODO: Add your code to check if the provided proof
	# *** matches what you would calculate -- and check that
	# *** the signature is valid

	print(False)	# Placeholder, until you add your code

